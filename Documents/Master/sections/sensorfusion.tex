\chapter{Sensor fusion}\label{cha:sensor_fusion}
In order to properly estimate the \abbrROV's attitude in the global coordinate system the \abbrROV needs sensors to measure external effects from its environment.
Unfortunately signals from sensors do not necessarily give direct information about attitude and their measurements are to some extent noisy. Algorithms can nevertheless be used to extract and combine the information from the different sensors into a better attitude estimate. The process of combining, or fusing, the information from several measurements with or without a motion model to produce an estimate of a state is called sensor fusion. One filter that can accomplish the task of fusing different measurements and estimating states in a non-linear dynamic system is the extended Kalman filter (\abbrEKF). 

To be able to understand how a filter like the extended Kalman filter works, it is important to understand the notation. In  \Tableref{tab:notationKalman} the notation used in this Chapter is listed.
 \begin{table}[htbp]
  \centering
  \caption{\label{tab:notationKalman}%
    The notation used for describing the extended Kalman filter.}
    \begin{tabular}{l p{0.7\linewidth}}
    \toprule%
    \textbf{Notation} & \textbf{Description} \\
    \otoprule%
    $\boldsymbol{x}$ & State vector.\\
    $\hat{\boldsymbol{x}}$ & State vector estimate.\\
    $\boldsymbol{y}$ & Measurement vector.\\
    $\boldsymbol{u}$ & Control signal vector.\\
    $\boldsymbol{v},\boldsymbol{e}$ & Noise vectors.\\
    $_k$ & At time $k$.\\
    $_{k|m}$ & At time $k$ given information up to time $m$.\\
    $f_{\boldsymbol{x}}$ & Jacobian of $f$ with respect to states $\boldsymbol{x}$.\\
    $f_{\boldsymbol{v}}$ & Jacobian of $f$ with respects to noise $\boldsymbol{v}$.\\
    $\text{E}(\boldsymbol{x})$ & The expected value of $\boldsymbol{x}$.\\
    $\text{Cov}(\boldsymbol{x})$ & The covariance of $\boldsymbol{x}$.\\
    \bottomrule%
 \end{tabular}
\end{table}

\section{The Extended Kalman Filter}
The Kalman filter (\abbrKF) is a linear state-space observer, it estimates both measurable and unmeasurable states, in a linear system \citep{sensorfusion}. It utilises a motion model, a model of the systems dynamics, in conjunction with measurements and linear measurement equations to provide the best possible estimate of the model's states. The Kalman filter finds the best possible linear filter for the given input $\boldsymbol{y}_{k}$ \citep{sensorfusion}. The extended Kalman filter can, unlike the regular Kalman filter, handle non-linear motion models and measurement equations. It accomplishes this by using a linearised model of the non-linear system and the measurement equations. If an \abbrEKF can provide satisfactory results depends on the rest terms from the Taylor expansion and it is therefore dependent on the degree of non-linearity of the system and the measurement equations \citep{sensorfusion}. As rule of thumb the rest term will be small enough if the system model is close to linear and if measurements are of good quality, meaning that the signal to noise ratio (\abbrSNR) is high \citep{sensorfusion}. 

The \abbrEKF algorithm is comprised of two key steps called updates.
The time update uses the current state estimates and the user specified motion model to predict the values of the states the next time instant. The second update is called the measurement update and it uses sampled sensor data in conjunction with the user specified measurement equations to improve the state estimates \citep{sensorfusion}.
If the measurements are independent a measurement update can be done at the arrival of each measurement without the need of a time update in between \citep[p. 170]{sensorfusion}.

The complete extended Kalman filter algorithm is summarised in \Algoref{alg:EKF}.
\begin{algorithm}
\caption{The extended Kalman filter algorithm.}
\label{alg:EKF}
  The extended Kalman filter applied on a system
    \begin{align*}
    \boldsymbol{x}_{k+1} &= f(\boldsymbol{x}_{k},\boldsymbol{u}_{k}, \boldsymbol{v}_{k})\\
    \boldsymbol{y}_{k} &= h(\boldsymbol{x}_{k},\boldsymbol{u}_{k},\boldsymbol{e}_{k})
    \end{align*} is given by the following algorithm:\\
    \textbf{Initialisation:}
    \begin{align*}
    \hat{\boldsymbol{x}}_{1|0} &= \text{E}(\boldsymbol{x}_{0})\\
    \boldsymbol{P}_{1|0} &= \text{Cov}(\boldsymbol{x}_{0})\\
    \end{align*}
     
    \textbf{Measurement update:}
    \begin{align*}
    \boldsymbol{S}_{k} &= h_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k-1},\boldsymbol{u}_{k}) \boldsymbol{P}_{k|k-1} h_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k-1},\boldsymbol{u}_{k})^{T} + \boldsymbol{R}_{k}\\
    \boldsymbol{K}_{k} &= \boldsymbol{P}_{k|k-1} h_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k-1},\boldsymbol{u}_{k})^{T} \boldsymbol{S}_{k}^{-1}\\
    \boldsymbol{\epsilon} &= \boldsymbol{y}_{k} - h(\hat{\boldsymbol{x}}_{k|k-1},\boldsymbol{u}_{k})\\
    \hat{\boldsymbol{x}}_{k|k} &= \hat{\boldsymbol{x}}_{k|k-1} + \boldsymbol{K}_{k}\boldsymbol{\epsilon}\\
    \boldsymbol{P}_{k|k} &= \boldsymbol{P}_{k|k-1} - \boldsymbol{P}_{k|k-1} h_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k-1},\boldsymbol{u}_{k})^{T} \boldsymbol{S}_{k}^{-1} h_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k-1},\boldsymbol{u}_{k}) \boldsymbol{P}_{k|k-1}\\
    \end{align*}
    
   \textbf{Time update:}
    \begin{align*}
    \hat{\boldsymbol{x}}_{k+1|k} &= f(\hat{\boldsymbol{x}}_{k|k},\boldsymbol{u}_{k})\\
    \boldsymbol{P}_{k+1|k} &= f_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k},\boldsymbol{u}_ {k})\boldsymbol{P}_{k|k} f_{\boldsymbol{x}}(\hat{\boldsymbol{x}}_{k|k},\boldsymbol{u}_{k})^{T} + f_{\boldsymbol{v}}(\hat{\boldsymbol{x}}_{k|k},\boldsymbol{u}_{k}) \boldsymbol{Q}_{k} f_{\boldsymbol{v}}(\hat{\boldsymbol{x}}_{k|k},\boldsymbol{u}_{k})^{T}
    \end{align*}    
\end{algorithm}

\section{Motion Model}\index{Motion model}
A \abbrKF uses knowledge of the system dynamics to improve the estimates of the model's states. It is therefore very important to choose a model that sufficiently describes the systems dynamics. The better the model the better the performance of the filter. In this thesis two different motion models have been used, a model using the measured angular velocities as inputs and a more advanced model which used the angular velocities as states. All models in this chapter use quaternions and thus quaternion normalisation is required as described in \Chapterref{cha:modelling}.

\subsection{Simple Model}\index{Quaternions}\label{sec:simple_model}
A simple model using the quaternion representation of $\etaVector$ was based on the quaternion kinematics model in \citet[p.47]{Tornqvist}. The model was expanded with depth as an extra state. The depth was modelled as state with constant position and was discretised using Euler forward. The complete simple model is 
\begin{equation}
\begin{pmatrix}
\etaVector_{k+1}\\
d_{k+1}
\end{pmatrix} 
=
 \begin{pmatrix}
 \boldsymbol{I}_{4\times4} + T_s \bar{\boldsymbol{T}}(\nuVector_k) & \boldsymbol{0}_{4\times1}\\
 \boldsymbol{0}_{1\times4} & \boldsymbol{I}_{1\times1} 
 \end{pmatrix}
 \begin{pmatrix}
 \etaVector_{k}\\
 d_k
 \end{pmatrix}
 +
  \begin{pmatrix}
  T_s \boldsymbol{T}(\etaVector_{k}) & \boldsymbol{0}_{4\times1}\\
  \boldsymbol{0}_{1\times3} & T_s
  \end{pmatrix}
  \begin{pmatrix}
  \boldsymbol{v}_{\etaVector}\\
  v_d 
  \end{pmatrix}
\end{equation}
Here $\bar{\boldsymbol{T}}(\nuVector)$ is defined as
\begin{equation}
\bar{T}(\nuVector) = \frac{1}{2}
\begin{pmatrix}
     0 &-p &-q &-r\\
     p & 0 & r &-q\\
     q &-r & 0 & p\\
     r & q &-p & 0
\end{pmatrix}
\end{equation} and $\boldsymbol{T}(\etaVector)$ is given in \eqref{eq:Tquat}.
It is important to note that this is an attitude model and thus $\etaVector$ and $\nuVector$ only contains quaternions and angular velocities respectively. Note that $\nuVector$ is not modelled as a state but is used as an input to reduce the dimension of the model as in \citet{Tornqvist}. 
\subsection{Expanded Model}\label{sec:expanded_model}
A second model was implemented to improve sensor fusion performance. This model incorporated bias estimates and $\nuVector$ as a constant position states. The entire model was discretised using Euler forward. The expanded model is 
\begin{equation}\label{eq:expanded_model}
\begin{pmatrix}
\etaVector_{k+1}\\
\nuVector_{k+1}\\
\boldsymbol{b}_{k+1}\\
d_{k+1}
\end{pmatrix}=
\begin{pmatrix}
\boldsymbol{I}_{4\times4} + T_s \bar{\boldsymbol{T}}(\nuVector_{k})& \boldsymbol{0}_{4\times7}\\
\boldsymbol{0}_{7\times4} & \boldsymbol{I}_{7\times7}\\
\end{pmatrix}
\begin{pmatrix}
\etaVector_{k}\\
\nuVector_{k}\\
\boldsymbol{b}_{k}\\
d_{k}
\end{pmatrix}
+\begin{pmatrix}
  \boldsymbol{v}_{\etaVector}\\
  \boldsymbol{v}_{\nuVector}\\
  \boldsymbol{v}_{\boldsymbol{b}}\\
  v_d 
\end{pmatrix}
\end{equation}

\subsection{Gyroscope Measurement Equation}
The \abbrROV is equipped with an \abbrIMU which contains a gyroscope and an accelerometer. The gyroscope measurement equation is 
\begin{equation}\label{eq:gyro}
\boldsymbol{y}_\text{Gyro}= \nuVector + \boldsymbol{b} =
 \begin{pmatrix}
p + b_p\\
q + b_q\\
r + b_r
\end{pmatrix}
\end{equation}
 $\boldsymbol{y}_\text{Gyro}$ is the reading from the \abbrIMU's gyroscope in $rad/s$. $b_p$, $b_q$ and $b_r$ are the gyroscope's biases in the \xPosition-, \yPosition- and \zPosition-axes. No outlier rejection is performed on the gyroscope measurements. Also note that \eqref{eq:gyro} is only used in conjunction with the expanded model \eqref{eq:expanded_model} since this models $\nuVector$ as a state. 

\subsection{Accelerometer Measurement Equation}
Since the \abbrIMU measures acceleration in addition to angular velocities, an accelerometer measurement update can be done with each new \abbrIMU data packet. The measurement equation for the accelerometer is
\begin{equation}
\boldsymbol{y}_{\text{Acc}} =
    \boldsymbol{R^n_b}^T
    \begin{pmatrix}
    0\\
    0\\
    -g
    \end{pmatrix}
\end{equation}
    where $\boldsymbol{R^n_b}$ is the rotation matrix defined in \Chapterref{cha:modelling} and $g$ is the gravitational constant. To ensure that only the gravitational constant $g$ is used to update the \abbrROV's attitude outlier rejection is performed. Accelerometer measurements are used if 
\begin{align*}
    \intertext{Keep if: }
    \abs{~||
    \boldsymbol{y}_{\text{Acc}}
||
    -g
     ~} < \epsilon
\end{align*} holds true.
Here is $\epsilon$ a design variable that tweaks how much the magnitude of the accelerometer measurement may deviate from $g$ before being considered an outlier.

\subsection{Magnetometer Measurement Equation}
The internal magnetometer enables the \abbrROV to measure the magnetic field strength in the three local axes $x$, $y$ and $z$. This data is used as a measurement in a measurement update that was constructed in the following way:
\begin{equation}
\boldsymbol{y}_{\text{Mag}} = 
    \boldsymbol{R^n_b}^T
    \begin{pmatrix}
        \sqrt{m_N^2 +m_E^2}\\
        0\\
        m_D
    \end{pmatrix}
\end{equation}
where $\boldsymbol{y}_{\text{Mag}}$ is the measured magnetic field in the body-fixed coordinate system. $m_N$, $m_E$ and $m_D$ are the components of the Earth's magnetic field in the $\north\east\down$ coordinate system and should be set during calibration.
To ensure that the good measurements are used an outlier rejection criteria was implemented. Magnetometer measurements are used if 
\begin{equation}
        \abs{~||
\boldsymbol{y}_{\text{Mag}}||
    -
    ||
    \begin{pmatrix}
        m_N\\
        m_E\\
        m_D
    \end{pmatrix}||
     ~} < \epsilon
\end{equation}
holds. Here is $\epsilon$ a design variable that tweaks how much the magnitude of the measurements may deviate from the magnitude of the Earth's magnetic field before being rejected.

\subsection{Pressure Sensor Measurement Equation}
The \abbrROV is also equipped with a pressure sensor. The sensor is placed in the rear or bow of the \abbrROV which in turn means that the attitude of the \abbrROV needs to be taken in to account when estimating the depth.
The measurement equation for the pressure sensor is
\begin{equation}
 \boldsymbol{y}_{\text{Pre}}=  \rho g (d + \begin{pmatrix}
    0 & 0 & 1
\end{pmatrix} \boldsymbol{R}^n_b 
\begin{pmatrix}
x_{\text{offset}}\\
0\\
0
\end{pmatrix}
\end{equation}
Here $\boldsymbol{y}_{\text{Pre}}$ is the measured water pressure in pascal, $\rho$ is the density of the water, $d$ is the current depth in meters and $x_{\text{offset}}$ is the pressure sensor's offset from the \abbrROV's \abbrCO in the $\xPosition$-direction. In this case $x_{\textrm{offset}}$ is a negative number. A basic form of outlier rejection is implemented in the pressure sensor measurement update. The update is performed if
\begin{equation}
    p \geq 0
\end{equation}